---
title: "Chromosome compaction - simple three-state model"
output: html_notebook
---

```{r}
library(ChromCom)
library(ggplot2)
```

## 11/07/2017

Writing introduction. First script to do simulation.


## 12/07/2017

Let's try if it works.

```{r, fig.width=5}
pars <- list(
  t1 = -60,
  dt = 0,
  r1 = 0.01,
  r2 = 0.01
)
chr <- ChromCom3(pars)
chr <- generateCells(chr)
plotTimelines(chr)
```

Parameter grid.

```{r}
parameterGrid <- function(pars, par1, range1, par2, range2) {
  melts <- NULL
  for(p1 in range1) {
    pars[[par1]] <- p1
    for(p2 in range2) {
      pars[[par2]] <- p2
      chr <- ChromCom3(pars)
      chr <- generateCells(chr)
      label1 <- sprintf("%s = %.3g", par1, p1)
      label2 <- sprintf("%s = %.3g", par2, p2)
      m <- meltTimelines(chr, label1=label1, label2=label2)
      melts <- rbind(melts, m)
    }
  }
  timelinePanel(melts)
}
```

```{r}
pars <- list(
  t1 = -30,
  dt = 0,
  r1 = 0.05,
  r2 = 0.01
)

range1 <- c(0.01, 0.05, 0.08, 0.12)
range2 <- c(0.01, 0.05, 0.08, 0.12)
parameterGrid(pars, "r1", range1, "r2", range2)
```
 I think we need to introduce a delay between pink and red.
 
 
```{r}
pars <- list(
  t1 = -30,
  dt = 10,
  r1 = 0.05,
  r2 = 0.01
)

range1 <- c(0.01, 0.03, 0.05, 0.10)
range2 <- c(0.01, 0.05, 0.08, 0.12)
parameterGrid(pars, "r1", range1, "r2", range2)
```

What about range of delays?

```{r}
pars <- list(
  t1 = -30,
  dt = 0,
  r1 = 0.03,
  r2 = 0.01
)

range1 <- c(0, 10, 20, 30)
range2 <- c(0.01, 0.05, 0.08, 0.12)
parameterGrid(pars, "dt", range1, "r2", range2)
```

Experimental data.

```{r, warning=FALSE, fig.width=5}
echr <- experimentalData(dataFile$control)
plotTimelines(echr, smooth=TRUE, k=15)
```


## 13/07/2017

Prepared [shiny app](https://shiny.compbio.dundee.ac.uk/marek_chromcom/param_tuner/) for deployment.

## 24/07/2017

Tomo suggested that the model parameters can be derived directly from data. We can write the following equations:

$\dot{B} = -k_1 B$

$\dot{P} = k_1 B - k_2 R$

$\dot{R} = k_2 P$

$B + P + R = 1$

Because proportions and their derivatives are observed, we can find the rates:

$k_1 = - \frac{\dot{B}}{B}$

$k_2 = \frac{\dot{R}}{P}$

This will require a lot of smoothing, otherwise the derivatives will be all over the place.

First, I see if I can recover rates from the generated data.

```{r}
timeDeriv <- function(chr, k=20) {
  ts <- list()
  for(col in chr$colours) {
    x <- chr$cnt[[col]] / chr$cnt$total
    x <- caTools::runmean(x, k)
    x <- ts(x, start=chr$timepars$start, deltat=chr$timepars$step)
    xdot <- diff(x)
    ts[[col]] <- x
    ts[[paste0(col, ".diff")]] <- xdot
  }
  ts
}
```

```{r}
plotRates <- function(chr, k=20) {
  ts <- timeDeriv(chr, k=k)
  k1 <- -ts$BB.diff / ts$BB
  k2 <- ts$R.diff / ts$P
  df <- data.frame(t=time(k1), k1=k1, k2=k2)
  m <- melt(df, measure.vars = c("k1", "k2"))
  ggplot(m, aes(x=t, y=value)) + geom_line(aes(colour=variable)) + ylim(0, 0.05)
}
```

```{r, fig.width=5, fig.height=3}
plotRates(chr, k=1)
```

Here is the rub. It needs lots of smoothing! These are smooth, generated data, and still produce crazy rates. This is because the time step is too small.

```{r}
plotRates(chr, k=20)
```

And now, for real data.

```{r}
plotTimelines(echr, smooth=TRUE, k=30)
plotRates(echr, k=30)
```
