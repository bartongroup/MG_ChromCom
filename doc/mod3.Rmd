---
title: "Chromosome compation - simple 3-state model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    number_sections: true
---

Collaborators: Tomo Tanaka, John Eykelenboom.

[shiny app](https://shiny.compbio.dundee.ac.uk/marek_chromcom/param_tuner/)

```{r setup, include=FALSE}
library(knitr)
library(mylib)
library(ggplot2)
library(gridExtra)
library(latex2exp)
library(kableExtra)

source("../R/lib.R")
binDir <- "../RData"

opts_chunk$set(fig.path='../figure/mpd3-', 
               cache.path='../cache/mod3-', 
               fig.align='center',
               external=TRUE,
               echo=FALSE,
               warning=FALSE,
               message=FALSE,
               fig.pos='H',
               fig.width=4,
               fig.height=3
              )
smth <- 5
```

# Data

```{r read_experimental_data}
echr <- lapply(dataFile, experimentalData)
```

In our data we distinguish four states, marked by colour: blue, brown, pink, red. For the purpose of the model we merge blue and brown together into one state. Here is the result of the experiment from `r nrow(echr$scramble$cells)` cells.

```{r fig_cells, fig.width=5}
plotCells(echr$scramble)
```

The next figure shows the proportions of each colour as a function of time. The curves are smoothed with a running mean over the window of `r smth` time points.

```{r fig_timeline, fig.width=5}
plotTimelines(echr$scramble, smooth=TRUE, k=smth)
```


# Model

The model consists of three states and a set of rules.

## States

* blue/brown (B)
* pink (P)
* red (R)
 
## Rules

- Simulation is carried out at a discrete time step of 1 min
- There is a fixed time for nuclear envelope breakdown, $t_0 = 0$; $t_0$ can be changed if necessary
- Time $t_1$ is a random variable with exponential distribution with time scale $\tau_1$
- Time $\Delta t_2$ is a random variable with exponential distribution with time scale $\tau_2$
- Time $\Delta t_3$ is a random variable with exponential distribution with time scale $\tau_3$
- The cell is in state B before time $t_0-t_1$.
- B$\rightarrow$P occurs after $t_0-t_1$ with rate $k_1$
- P$\rightarrow$R occurs after $t_0-t_1 + \Delta t_2$ with rate $k_2$*
- P$\rightarrow$B occurs after $t_0-t_1 + \Delta t_3$ with rate $k_3$

\* A switch, $t_{2, ref}$ was introduced to the model, selecting the reference for time $t_2$. In the default position ($t_{2, ref} = 1$) the B$\rightarrow$P activation time is $t_0-t_1 + \Delta t_2$. When the switch is set to $t_{2, ref} = 0$, the activation time is $t_0 + \Delta t_2$, that is, it can only occur after the nuclear envelope breakdown. The idea of the switch was to separate pink and red curves, as observed in some data sets.

I use a Markov chain approach. The next state is generated from the current state based on rules outlined above. The rates, $k$, are converted into probabilities over a given time step $\Delta t$ as $Pr = 1 - e^{1 - k\Delta t}$. The transition time, $t_1$, is generated before the simulation starts for a given cell.

The cell timeline is repeated for $n_{\rm cell}$ times and then the colour proportions are found at each time point.

## Example

Here is an example of the model.

```{r model_example_t1, fig.width=4, fig.height=3}
pars <- c3pars(
  t0 = 0,
  tau1 = 10,
  tau2 = 10,
  k1 = 0.05,
  k2 = 0.04,
  t2ref = 1
)
chr <- ChromCom3(pars)
chr <- generateCells(chr, nsim=3000)
plotTimelines(chr, withpars=TRUE)
```

And here is an example of the the model where P$\rightarrow$R transition can occur only after $t_0 = 0$.

```{r model_example_t0, fig.width=4, fig.height=3}
pars <- c3pars(
  t0 = -10,
  tau1 = 10,
  tau2 = 10,
  k1 = 0.06,
  k2 = 0.03,
  t2re = 0
)
chr <- ChromCom3(pars)
chr <- generateCells(chr, nsim=3000)
plotTimelines(chr, withpars=TRUE)
```


## Parameter tuner

There is a [shiny app](https://shiny.compbio.dundee.ac.uk/marek_chromcom/param_tuner/) that allows tuning parameters in search for the best solution.

# Fitting model to the data

I attempted fitting model to our data. It is not an easy task, as the model is stochastic. After some testing I found that modified BFGS (a quasi-Newton method, also known as a variable metric algorithm, by Broyden, Fletcher, Goldfarb and Shanno, 1970) which allows box constraints (Byrd et al. 1995), gives reasonable results. Again, due to stochasticity of the model, this algorithm often finds false local minima. I run it several times to find the best minimum. It is a crude and time-consuming method, but gives results better than manual tuning.

Fitting is constrained to time points between -50 and 30 min. The minimized quantity is

${\rm rms} = \sqrt{\sum_{c \in \{B,P,R\}} \sum_i (O_{c,i} - E_{c,i})^2}$

that is, the square root of the sum of squared residuals over all time points and all colours.

## Default model

First, we fit the model with $\tau_1$, $\tau_2$, $k_1$ and $k_2$ free. To improve the chances of finding the correct global minimum, I run the fit with 10,000 cells and 100 tries.

### Scramble

We suspect that $t_0$ might not be exactly zero. Hence I fit the model with $t_0 = 0, -5, -10, -15$ minutes.

```{r scramble_t0, include=FALSE}
pars <- c3pars(
  t0 = -10,
  tau1 = 15.3,
  tau2 = 9,
  k1 = 0.047,
  k2 = 0.064
)
free <- c("tau1", "k1", "k2", "tau2")

neb <- c(0, -5, -10, -15)
chr.scr <- lapply(neb, function(t0) {
  name <- paste0("fitt_scramble_n10000_t.", -t0, "_tau1_k1_k2_tau2")
  cacheData(name, fitChr, echr$scramble, pars, free, nsim=10000, ntry=100, ncores=4, binDir=binDir, cacheonly=TRUE)
})
names(chr.scr) <- as.character(-neb)
```

```{r fig_scramble_t0, fig.width=5}
for(t0 in names(chr.scr)) {
  print(plotTimelines(chr.scr[[t0]], expdata = echr$scramble, withpars=TRUE))
}
```

I think the issue here is not $t_0$ but the fact that the red curve growths is too fast and the model cannot do it.

### All conditions

```{r, eval=FALSE}
# Somehow, the wrong version was used to do fitting and pars$t2ref is a string.
# Need to convert (only once).
for(set in names(dataFile)) {
  name <- paste0("fits_", set, "_ref1_t0_n100000_tau1_k1_k2_tau2")
  chr <- cacheData(name, binDir=binDir, cacheonly=TRUE)
  chr$pars$t2ref <- 1L
  file <- paste0(binDir, "/", name, ".RData")
  obj <- chr
  save(obj, file=file)
}
```

```{r plot_all_conditions_function}
plotAllConditions <- function(suffix) {
  chr <- lapply(names(dataFile), function(set) {
    name <- paste0("fits_", set, "_", suffix)
    cacheData(name, binDir=binDir, cacheonly=TRUE)
  })
  names(chr) <- names(dataFile)
  P <- list()
  for(name in names(dataFile)) {
    P[[name]] <- plotTimelines(chr[[name]], expdata = echr[[name]], withpars=TRUE, title=name, title.size=9)
  }
  P
}
```


Here are fit results for all conditions with $t_0$ fixed at zero and four parameters free: $\tau_1$, $\tau_2$, $k_1$ and $k_2$.


```{r fig_all_conditions, fig.width=12, fig.height=20}
#P <- plotAllConditions("ref1_t0_n10000_tau1_k1_k2_tau2")
#grid.arrange(grobs=P, ncol=2)
```


## Switch: P$\rightarrow$R only after $t_0$

Here are results from a modified model, where P$\rightarrow$R transition can happen only after $t_0$. By default  $t_0 = 0$ and the results are shown in the left panels below. As you can see, the red curve in the model lags behind the red curve in the data. Hence, I fitted the data again, but fixing $t_0 = -10$ min this time (right panels). This aligns the red curves a little better.

We can also see that the pink curve is more peaked, as opposed to the smooth rise and decay in the default model.

```{r fig_all_conditions_switch, fig.width=12, fig.height=28}
#P1 <- plotAllConditions("ref0_t0_n1000_tau1_k1_k2_tau2")
#P2 <- plotAllConditions("ref0_t10_n1000_tau1_k1_k2_tau2")
#P <- c(rbind(P1, P2))  # interleave lists (beautiful trick!)
#grid.arrange(grobs=P, ncol=2)
```

# Four-colour plots

Here I create cell-line plots for all data sets using four colours.


```{r four_colour}
echr4 <- lapply(dataFile, function(file) experimentalData(file, map=model.colours.extended))
P <- lapply(names(echr4), function(nm) plotCells(echr4[[nm]], palette=c("blue", "chocolate4", "pink", "red")) + labs(title=nm))
names(P) <- names(echr4)
```

```{r fig_four_colours, fig.width=12, fig.height=28}
grid.arrange(grobs=P, ncol=2) 
```

PDF files:

```{r four_colours_pdf}
public_html <- "http://www.compbio.dundee.ac.uk/user/mgierlinski/chromcom/"
df <- NULL
for(nm in names(P)) {
  file <- paste0(nm, "_4colour.pdf")
  remote.file <- paste0("/home/mgierlinski/projects/chromcom/pdf/", file)
  url <- paste0(public_html, "pdf/", file)
  link <- paste0("[", nm, "](", url, ")")
  df <- rbind(df, data.frame(link=link))
  ggsave(remote.file, P[[nm]], device="pdf")
}
kable(df, format="html", row.names=FALSE) %>% kable_styling("condensed", full_width = FALSE, position="left", font_size=12)
```
