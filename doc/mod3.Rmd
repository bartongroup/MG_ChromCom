---
title: "Chromosome compation - simple 3-state model"
author: "Marek Gierlinski"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    number_sections: true
---


```{r setup, include=FALSE}
library(ChromCom)
library(knitr)
library(mylib)
library(ggplot2)
library(gridExtra)
library(latex2exp)
binDir <- "../RData"
opts_chunk$set(fig.path='../figure/mpd3-', 
               cache.path='../cache/mod3-', 
               fig.align='center',
               external=TRUE,
               echo=FALSE,
               warning=FALSE,
               message=FALSE,
               fig.pos='H',
               fig.width=4,
               fig.height=3
              )
```

# Data

```{r}
echr.scr <- experimentalData(dataFile$scramble)
echr.d2 <- experimentalData(dataFile$NCAPD2)
echr.d3 <- experimentalData(dataFile$NCAPD3)
echr.smc <- experimentalData(dataFile$SMC2)
smth <- 5
```

In our data we distinguish four states, marked by colour: blue, brown, pink, red. For the purpose of the model we merge blue and brown together into one state. Here is the result of the experiment from `r nrow(echr.scr$cells)` cells.

```{r}
plotCells(echr.scr)
```

The next figure shows the proportions of each colour as a function of time. The curves are smoothed with a running mean over the window of `r smth` time points.

```{r}
plotTimelines(echr.scr, smooth=TRUE, k=smth)
```


# Model

The model consists of three states and a set of rules.

## States

* blue/brown (B)
* pink (P)
* red (R)
 
## Rules

- Simulation is carried out at a discrete time step of 1 min
- Time $t_1$ is a random variable with exponential distirbution with time scale $\tau$
- The cell is in state B before time $-t_1$.
- B$\rightarrow$P occurs after $-t_1$ with rate $k_1$
- P$\rightarrow$R occurs after $-t_1 + \Delta t_2$ with rate $k_2$
- P$\rightarrow$B occurs after $-t_1 + \Delta t_3$ with rate $k_3$


I use a Markov chain approach. The next state is generated from the current state based on rules outlined above. The rates, $k$, are converted into probabilities over a given time step $\Delta t$ as $Pr = 1 - e^{1 - k\Delta t}$. The transition time, $t_1$, is generated before the simulation starts for a given cell.

The cell timeline is repeated for $n_{\rm cell}$ times and then the colour proportions are found at each time point.

## Example

Here is an example of the model.

```{r, fig.width=4, fig.height=3}
pars <- c3pars(
  tau = 20,
  dt2 = 0,
  k1 = 0.05,
  k2 = 0.03
)
chr <- ChromCom3(pars)
chr <- generateCells(chr, nsim=3000)
plotTimelines(chr, withpars=TRUE)
```

## Parameter tuner

There is a [shiny app](https://shiny.compbio.dundee.ac.uk/marek_chromcom/param_tuner/) that allows tuning parameters in search for the best solution.

# Fitting model to the data

I attempted fitting model to our data. It is not an easy task, as the model is stochastic. After some testing I found that modified BFGS (a quasi-Newton method, also known as a variable metric algorithm, by Broyden, Fletcher, Goldfarb and Shanno, 1970) which allows box constraints (Byrd et. al. 1995), gives reasonable results. Again, due to stochasticity of the model, this algorithm often finds false local minima. I run it several times to find the best minimum. It is a crude and time-consuming method, but gives results better than manual tuning.

Fitting is constrained to time points between -90 and 30 min. The minimized quantity is

${\rm rms} = \sqrt{\sum_{c \in \{B,P,R\}} \sum_i (O_{c,i} - E_{c,i})^2}$

that is, the square root of the sum of squared residuals over all time points and all colours.

## Four parameters free

First, we fit the model with $\tau$, $\Delta t_2$, $k_1$ and $k_2$ free. To improve the chances of finding the correct global minimum, I run the fit with 10,000 cells and 100 tries.

### Scramble

```{r, fig.width=5}
pars <- c3pars()
free <- c("tau", "k1", "k2", "dt2")
chr.scr <- cacheData("fitv_scramble_n10000_tau_k1_k2_dt2", fitChr, echr.scr, pars, free, nsim=10000, ntry=100, ncores=6, binDir=binDir)
plotTimelines(chr.scr, expdata = echr.scr, withpars=TRUE)
```

### NCAPD2

```{r, fig.width=5}
pars <- c3pars()
free <- c("tau", "k1", "k2", "dt2")
chr.d2 <- cacheData("fitv_NCAPD2_n10000_tau_k1_k2_dt2", fitChr, echr.d2, pars, free, nsim=10000, ntry=100, ncores=6, binDir=binDir)
plotTimelines(chr.d2, expdata = echr.d2, withpars=TRUE)
```


### NCAPD3

```{r, fig.width=5}
pars <- c3pars()
free <- c("tau", "k1", "k2", "dt2")
chr.d3 <- cacheData("fitv_NCAPD3_n10000_tau_k1_k2_dt2", fitChr, echr.d3, pars, free, nsim=10000, ntry=100, ncores=6, binDir=binDir)
plotTimelines(chr.d3, expdata = echr.d3, withpars=TRUE)
```

### SMC2

```{r, fig.width=5}
pars <- c3pars()
free <- c("tau", "k1", "k2", "dt2")
chr.smc <- cacheData("fitv_SMC2_n10000_tau_k1_k2_dt2", fitChr, echr.smc, pars, free, nsim=10000, ntry=100, ncores=6, binDir=binDir)
plotTimelines(chr.smc, expdata = echr.smc, withpars=TRUE)
```

## Some parameters fixed

This was an older idea, do we want to do someting similar again?

- fit scramble with $t_1$, $k_1$ and $k_2$ free
- for NCAPD2 we expect only $k_2$ to change, so fix $k_1$ from scramble
- for NCAPD3 we expect only $k_1$ to change, so fix $k_2$ from scramble; however, John tried this manually and it didn't work very well, so we might free both ks
- for SMC2 $k_1$ fixed from NCAPD3, $k_2$ fixed from NCAPD2 and see if this matches; then do a fit
- lets keep all $\Delta t$ fixed

